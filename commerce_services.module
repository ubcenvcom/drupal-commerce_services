<?php

/**
 * @file
 * Defines Services resources for Drupal Commerce entities and systems.
 */


/**
 * Implements hook_services_resources().
 */
function commerce_services_services_resources() {
  $resources = array();

  if (module_exists('node') && module_exists('commerce_product_reference')) {
    // Define a resource for product display nodes, which returns node and
    // product data together that is more useful for building complex Add to
    // Cart forms than just product data.
    $resources['product-display'] = array(
      '#api_version' => 3002,
      'operations' => array(
        // Define the index callback for a GET to /product-display.
        'index' => array(
          'help' => 'Returns a pageable list of product displays.',
          'callback' => 'commerce_services_product_display_index',
          'file' => array('type' => 'inc', 'module' => 'commerce_services', 'name' => 'resources/product_display'),
          'access arguments' => array('access content'),
          'args' => array(
            array(
              'name' => 'fields',
              'type' => 'string',
              'description' => 'A comma separated list of field or property names from product display nodes to include in the result set. Will be converted to an array before being passed to the operation callback.',
              'optional' => TRUE,
              'source' => array('param' => 'fields'),
              'default value' => '',
              'commerce_services_explode' => ',',
              'commerce_services_required_fields' => array('nid'),
            ),
            array(
              'name' => 'expand_entities',
              'type' => 'int',
              'description' => 'An integer depth to which entity reference field values should be expanded into full entities in a corresponding property on returned entities.',
              'optional' => TRUE,
              'source' => array('param' => 'expand_entities'),
              'default value' => 1,
            ),
            array(
              'name' => 'flatten_fields',
              'type' => 'string',
              'description' => 'A string indicating whether or not field value arrays should be flattened; accepts true or false.',
              'optional' => TRUE,
              'source' => array('param' => 'flatten_fields'),
              'default value' => 'true',
            ),
            array(
              'name' => 'filter',
              'type' => 'array',
              'description' => 'An array of field or property names from product display nodes paired with values to use to filter the result set.',
              'optional' => TRUE,
              'source' => array('param' => 'filter'),
              'default value' => array('status' => 1),
              'commerce_services_field_populate' => 'node',
            ),
            array(
              'name' => 'filter_op',
              'type' => 'array',
              'description' => 'An array of field or property names from product display nodes paired with the operator to use when filtering the result set.',
              'optional' => TRUE,
              'source' => array('param' => 'filter_op'),
              'default value' => array(),
              'commerce_services_match_keys' => array(
                'arg' => 'filter',
                'default value' => '=',
              ),
            ),
            array(
              'name' => 'sort_by',
              'type' => 'string',
              'description' => 'A comma separated list of field or property names from product display nodes by which to sort the result set.',
              'optional' => TRUE,
              'source' => array('param' => 'sort_by'),
              'default value' => 'created',
              'commerce_services_explode' => ',',
            ),
            array(
              'name' => 'sort_order',
              'type' => 'string',
              'description' => 'A comma separated list of order specifiers (DESC or ASC) indicating the direction the sort_by values should be applied to the result set.',
              'optional' => TRUE,
              'source' => array('param' => 'sort_order'),
              'default value' => 'DESC',
              'commerce_services_explode' => ',',
            ),
            array(
              'name' => 'limit',
              'type' => 'int',
              'description' => 'The number of product displays to retrieve.',
              'optional' => TRUE,
              'source' => array('param' => 'limit'),
              'default value' => 10,
            ),
            array(
              'name' => 'offset',
              'type' => 'int',
              'description' => 'The zero-based index from which to start retrieving product displays.',
              'optional' => TRUE,
              'source' => array('param' => 'offset'),
              'default value' => 0,
            ),
          ),
        ),

        // Define the retrieve callback for a GET to /product-display/%node.
        'retrieve' => array(
          'help' => 'Returns a single product display specified by its node ID.',
          'callback' => 'commerce_services_product_display_retrieve',
          'file' => array('type' => 'inc', 'module' => 'commerce_services', 'name' => 'resources/product_display'),
          'access callback' => 'commerce_services_product_display_access',
          'access arguments' => array('view'),
          'access arguments append' => TRUE,
          'args' => array(
            array(
              'name' => 'nid',
              'type' => 'int',
              'description' => 'The node ID of the product display to retrieve.',
              'optional' => FALSE,
              'source' => array('path' => 0),
            ),
            array(
              'name' => 'expand_entities',
              'type' => 'int',
              'description' => 'An integer depth to which entity reference field values should be expanded into full entities in a corresponding property on the returned entity.',
              'optional' => TRUE,
              'source' => array('param' => 'expand_entities'),
              'default value' => 1,
            ),
            array(
              'name' => 'flatten_fields',
              'type' => 'string',
              'description' => 'A string indicating whether or not field value arrays should be flattened; accepts true or false.',
              'optional' => TRUE,
              'source' => array('param' => 'flatten_fields'),
              'default value' => 'true',
            ),
          ),
        ),
      ),
    );
  }

  if (module_exists('commerce_product')) {
    // Define a resource for actual Commerce Product entities, including actions
    // to add particular products to a shopping cart.
    $resources['product'] = array(
      '#api_version' => 3002,
      'operations' => array(
        // Define the index callback for a GET to /product.
        'index' => array(
          'help' => 'Returns a pageable list of products.',
          'callback' => 'commerce_services_product_index',
          'file' => array('type' => 'inc', 'module' => 'commerce_services', 'name' => 'resources/product'),
          'access callback' => 'commerce_services_product_index_access',
          'args' => array(
            array(
              'name' => 'fields',
              'type' => 'string',
              'description' => 'A comma separated list of field or property names from products to include in the result set.  Will be converted to an array before being passed to the operation callback.',
              'optional' => TRUE,
              'source' => array('param' => 'fields'),
              'default value' => '',
              'commerce_services_explode' => ',',
              'commerce_services_required_fields' => array('product_id'),
            ),
            array(
              'name' => 'expand_entities',
              'type' => 'int',
              'description' => 'An integer depth to which entity reference field values should be expanded into full entities in a corresponding property on returned entities.',
              'optional' => TRUE,
              'source' => array('param' => 'expand_entities'),
              'default value' => 1,
            ),
            array(
              'name' => 'flatten_fields',
              'type' => 'string',
              'description' => 'A string indicating whether or not field value arrays should be flattened; accepts true or false.',
              'optional' => TRUE,
              'source' => array('param' => 'flatten_fields'),
              'default value' => 'true',
            ),
            array(
              'name' => 'filter',
              'type' => 'array',
              'description' => 'An array of field or property names from products paired with values to use to filter the result set.',
              'optional' => TRUE,
              'source' => array('param' => 'filter'),
              'default value' => array(),
              'commerce_services_field_populate' => 'commerce_product',
            ),
            array(
              'name' => 'filter_op',
              'type' => 'array',
              'description' => 'An array of field or property names from products paired with the operator to use when filtering the result set.',
              'optional' => TRUE,
              'source' => array('param' => 'filter_op'),
              'default value' => array(),
              'commerce_services_match_keys' => array(
                'arg' => 'filter',
                'default value' => '=',
              ),
            ),
            array(
              'name' => 'sort_by',
              'type' => 'string',
              'description' => 'A comma separated list of field or property names from products by which to sort the result set.',
              'optional' => TRUE,
              'source' => array('param' => 'sort_by'),
              'default value' => 'product_id',
              'commerce_services_explode' => ',',
            ),
            array(
              'name' => 'sort_order',
              'type' => 'string',
              'description' => 'A comma separated list of order specifiers (DESC or ASC) indicating the direction the sort_by values should be applied to the result set.',
              'optional' => TRUE,
              'source' => array('param' => 'sort_order'),
              'default value' => 'ASC',
              'commerce_services_explode' => ',',
            ),
            array(
              'name' => 'limit',
              'type' => 'int',
              'description' => 'The number of products to retrieve.',
              'optional' => TRUE,
              'source' => array('param' => 'limit'),
              'default value' => 10,
            ),
            array(
              'name' => 'offset',
              'type' => 'int',
              'description' => 'The zero-based index from which to start retrieving products.',
              'optional' => TRUE,
              'source' => array('param' => 'offset'),
              'default value' => 0,
            ),
          ),
        ),

        // Define the retrieve callback for a GET to /product/%commerce_product.
        'retrieve' => array(
          'help' => 'Returns a single product specified by its product ID.',
          'callback' => 'commerce_services_product_retrieve',
          'file' => array('type' => 'inc', 'module' => 'commerce_services', 'name' => 'resources/product'),
          'access callback' => 'commerce_services_product_retrieve_access',
          'access arguments append' => TRUE,
          'args' => array(
            array(
              'name' => 'product_id',
              'type' => 'int',
              'description' => 'The product ID of the product to retrieve.',
              'optional' => FALSE,
              'source' => array('path' => 0),
            ),
            array(
              'name' => 'expand_entities',
              'type' => 'int',
              'description' => 'An integer depth to which entity reference field values should be expanded into full entities in a corresponding property on returned entities.',
              'optional' => TRUE,
              'source' => array('param' => 'expand_entities'),
              'default value' => 1,
            ),
            array(
              'name' => 'flatten_fields',
              'type' => 'string',
              'description' => 'A string indicating whether or not field value arrays should be flattened; accepts true or false.',
              'optional' => TRUE,
              'source' => array('param' => 'flatten_fields'),
              'default value' => 'true',
            ),
          ),
        ),

        // Define the delete callback for a DELETE to /product/%commerce_product.
        'delete' => array(
          'help' => 'Deletes a single product specified by its product ID.',
          'callback' => 'commerce_services_product_delete',
          'file' => array('type' => 'inc', 'module' => 'commerce_services', 'name' => 'resources/product'),
          'access callback' => 'commerce_services_product_delete_access',
          'access arguments append' => TRUE,
          'args' => array(
            array(
              'name' => 'product_id',
              'type' => 'int',
              'description' => 'The product ID of the product to delete.',
              'optional' => FALSE,
              'source' => array('path' => 0),
            ),
          ),
        ),
      ),
    );
  }

  if (module_exists('commerce_cart')) {
    // Define a resource for shopping cart orders, which retrieve and manipulate
    // orders by user ID.
    // $resources['cart'] = array();
  }

  if (module_exists('commerce_order')) {
    // Define a resource for Commerce Order entities.
    // $resources['order'] = array();
  }

  return $resources;
}

/**
 * Implements hook_services_request_preprocess_alter().
 *
 * This preprocess function performs a variety of Commerce Services specific
 * operations on resource arguments. Any argument using one of the following
 * keys on any resource will be preprocessed:
 *
 * commerce_services_explode:
 *
 * For certain resources, we define arguments as strings that should be exploded
 * into arrays prior to being passed to the resource callback. To indicate this,
 * our argument definitions may include a commerce_services_explode key whose
 * value is the delimiter this preprocess function will use to explode the value
 * of that argument into an array.
 *
 * Example: the product-display resource includes an index callback definition
 * that may accept a fields argument. This argument was defined as a string
 * derived from the GET parameters of the API request, but prior to invoking the
 * index callback, this preprocess function will see that the argument indicates
 * it is a comma delimited string and explode it accordingly.
 *
 * commerce_services_required_fields:
 *
 * Additionally, when a fields argument contains a value from the API request,
 * there may be certain fields or properties that should always be returned even
 * if not included in the argument value. These may be indicated in argument
 * definitions via the commerce_services_required_fields array. This preprocess
 * function will ensure that the fields array always includes required fields.
 *
 * commerce_services_field_populate:
 *
 * As a best practice, we really try to avoid array notation in our query
 * parameters. However, if you want a resource callback argument to be an
 * associative array, this would typically be your only option. The primary use
 * case in Commerce Services is to apply a filter to an index query, where you
 * would specify a field or property name and the corresponding value that the
 * query should be filtered by: GET /product-display?filter[status]=1
 *
 * To avoid this, we make the commerce_services_field_populate option available.
 * Its value should be the entity type for the query that will be used to
 * generate the response. During preprocessing, this function will look for any
 * query parameter whose key matches a field or property name on the given
 * entity type and add it directly to the argument's array. Thus, instead of the
 * array notation demonstrated above, you could: GET /product-display?status=1
 *
 * The only exception to this will be field or property names that collide with
 * actual argument names for the operation callback. Thus, if the index
 * operation actually had an argument called status, you would have to revert to
 * array notation to apply a filter on the status property.
 *
 * commerce_services_match_keys:
 *
 * Finally, this preprocess function also accommodates key matching between
 * related array arguments. One argument may specify another argument whose keys
 * should all be represented in its own value array, providing a default value
 * to fill in for any keys that are missing.
 *
 * Example: the product-display resource includes an index callback definition
 * that may accept filter and filter_op array arguments. In the event that an
 * operator is not specified for a particular filter, it should default to a
 * simple equality check with the '=' operator. Therefore, the filter_op
 * argument uses the commerce_services_match_keys property to specify that its
 * array keys should match those of the filter argument, using '=' as the
 * default value.
 */
function commerce_services_services_request_preprocess_alter($controller, &$args) {
  // Build an associative array of arguments whose keys are their names and
  // values their numeric key in the $args array.
  $arg_names = array();

  foreach ($controller['args'] as $key => $value) {
    $arg_names[$value['name']] = $key;
  }

  // Loop over the argument metadata in the controller looking for any that
  // include any of our special keys.
  foreach ($controller['args'] as $key => $value) {
    // If this argument needs to be exploded into an array...
    if (!empty($value['commerce_services_explode'])) {
      // Explode the argument using the specified delimiter.
      if (!empty($args[$key])) {
        $args[$key] = explode($value['commerce_services_explode'], $args[$key]);
      }
      else {
        // Otherwise ensure it is just converted to an array.
        $args[$key] = array();
      }
    }

    // If this argument is for a fields array that we want to ensure contains
    // one or more required values...
    if (!empty($value['commerce_services_required_fields']) && !empty($args[$key])) {
      foreach ($value['commerce_services_required_fields'] as $required_field) {
        if (!in_array($required_field, $args[$key])) {
          $args[$key][] = $required_field;
        }
      }
    }

    // If this argument should be populated from other query parameters that
    // don't match other arguments on the operation...
    if (!empty($value['commerce_services_field_populate'])) {
      // Loop over the query parameters.
      foreach ($_GET as $param_key => $param_value) {
        // Continue if this is either the 'q' parameter or the name of an
        // argument for the operation callback.
        if ($param_key === 'q' || in_array($param_key, array_keys($arg_names), TRUE)) {
          continue;
        }

        // If this parameter key is a property for the specified entity type,
        // add it to the argument's value array now.
        if (in_array($param_key, array_keys(commerce_services_entity_type_properties($value['commerce_services_field_populate'])), TRUE)) {
          $args[$key][$param_key] = $param_value;
        }
        else {
          // Otherwise look and see if the parameter key begins with a field
          // name, assuming it must be either a field name or field column name.
          foreach (array_keys(commerce_services_entity_type_fields($value['commerce_services_field_populate'])) as $field_name) {
            if (strpos($param_key, $field_name) === 0) {
              $field_info = field_info_field($field_name);

              // If it is the field name and the field type has a single column
              // schema, add it to the argument's value array now.
              if ($field_name == $param_key && count($field_info['columns']) == 1) {
                $args[$key][$param_key] = $param_value;
                break;
              }
              else {
                // Otherwise if the parameter key contains a valid column
                // specification for the field type, add it to the argument's
                // value array as well.
                $column = substr($param_key, strlen($field_name) + 1);

                if (in_array($column, array_keys($field_info['columns']))) {
                  $args[$key][$param_key] = $param_value;
                  break;
                }
              }
            }
          }
        }
      }
    }

    // If this argument is an associative array that needs keys matching some
    // other array argument...
    if (!empty($value['commerce_services_match_keys'])) {
      $matching_arg_key = $arg_names[$value['commerce_services_match_keys']['arg']];

      if (!empty($args[$matching_arg_key])) {
        // Loop over the argument value that this argument's keys should match.
        foreach ($args[$matching_arg_key] as $arg_key => $arg_value) {
          if (empty($args[$key][$arg_key])) {
            $args[$key][$arg_key] = $value['commerce_services_match_keys']['default value'];
          }
        }
      }
    }
  }
}

/**
 * Unsets properties from a stdClass object so that only those desired remain.
 *
 * @param $object
 *   A stdClass object typically representing an entity.
 * @param $fields
 *   An array of field or property names to leave on the object. All others will
 *   be unset.
 */
function commerce_services_object_filter($object, $fields) {
  foreach ((array) $object as $key => $value) {
    if (!in_array($key, $fields)) {
      unset($object->$key);
    }
  }
}

/**
 * Returns a list of properties for the specified entity type.
 *
 * For the purpose of the Commerce Services module, the properties returned are
 * those that correspond to a database column as determined by the Entity API.
 * These may be used to filter and sort index queries.
 *
 * @param $entity_type
 *   Machine-name of the entity type whose properties should be returned.
 *
 * @return
 *   An associative array of properties for the specified entity type with the
 *   key being the property name and the value being the corresponding schema
 *   field on the entity type's base table.
 */
function commerce_services_entity_type_properties($entity_type) {
  $properties = drupal_static(__FUNCTION__);

  if (!isset($properties[$entity_type])) {
    $info = entity_get_property_info($entity_type);
    $properties[$entity_type] = array();

    // Loop over only the properties of the entity type.
    foreach ($info['properties'] as $key => $value) {
      // If the value specifies a schema field...
      if (!empty($value['schema field'])) {
        $properties[$entity_type][$key] = $value['schema field'];
      }
    }
  }

  return $properties[$entity_type];
}

/**
 * Returns a list of fields for the specified entity type.
 *
 * @param $entity_type
 *   Machine-name of the entity type whose properties should be returned.
 * @param $bundle
 *   Optional bundle name to limit the returned fields to.
 *
 * @return
 *   An associative array of fields for the specified entity type with the key
 *   being the field name and the value being the Entity API property type.
 */
function commerce_services_entity_type_fields($entity_type, $bundle = NULL) {
  $fields = drupal_static(__FUNCTION__);

  if (!isset($fields[$entity_type])) {
    $info = entity_get_property_info($entity_type);
    $fields = array();

    // Loop over the bundles info to inspect their fields.
    foreach ($info['bundles'] as $bundle_name => $bundle_info) {
      // Loop over the properties on the bundle to find field information.
      foreach ($bundle_info['properties'] as $key => $value) {
        if (!empty($value['field'])) {
          $fields[$entity_type][$bundle_name][$key] = $value['type'];
        }
      }
    }
  }

  // If a specific bundle's fields was requested, return just those.
  if (!empty($bundle)) {
    return $fields[$entity_type][$bundle];
  }
  else {
    // Otherwise combine all the fields for various bundles of the entity type
    // into a single return value.
    $combined_fields = array();

    foreach ($fields[$entity_type] as $bundle_name => $bundle_fields) {
      $combined_fields += $bundle_fields;
    }

    return $combined_fields;
  }
}

/**
 * Adds property and field conditions to an index EntityFieldQuery.
 *
 * @param $query
 *   The EntityFieldQuery object being built for the index query.
 * @param $entity_type
 *   Machine-name of the entity type of the index query.
 * @param $filter
 *   An associative array of property names, single column field names, or
 *   multi-column field column names with their values to use to filter the
 *   result set of the index request.
 * @param $filter_op
 *   An associative array of field and property names with the operators to use
 *   when applying their filter conditions to the index request query.
 */
function commerce_services_index_query_filter($query, $entity_type, $filter, $filter_op) {
  // Loop over each filter field to add them as property or field conditions on
  // the query object. This function assumes the $filter and $filter_op arrays
  // contain matching keys to set the correct operator to the filter fields.
  foreach ($filter as $filter_field => $filter_value) {
    // Determine the corresponding operator for this filter field, defaulting to
    // = in case of an erroneous request.
    $operator = '=';

    if (!empty($filter_op[$filter_field])) {
      $operator = $filter_op[$filter_field];
    }

    // If the current filter field is a property, use a property condition.
    $properties = commerce_services_entity_type_properties($entity_type);

    if (in_array($filter_field, array_keys($properties))) {
      $query->propertyCondition($properties[$filter_field], $filter_value, $operator);
    }
    else {
      // Look for the field name among the entity type's field list.
      foreach (commerce_services_entity_type_fields($entity_type) as $field_name => $field_type) {
        // If the filter field begins with a field name, then either the filter
        // field is the field name or is a column of the field.
        if (strpos($filter_field, $field_name) === 0) {
          $field_info = field_info_field($field_name);

          // If it is the field name and the field type has a single column
          // schema, add the field condition to the index query.
          if ($field_name == $filter_field && count($field_info['columns']) == 1) {
            $column = key($field_info['columns']);
            $query->fieldCondition($field_name, $column, $filter_value, $operator);
            break;
          }
          else {
            // Otherwise if the filter field contains a valid column specification
            // for the field type, add the field condition to the index query.
            $column = substr($filter_field, strlen($field_name) + 1);

            if (in_array($column, array_keys($field_info['columns']))) {
              $query->fieldCondition($field_name, $column, $filter_value, $operator);
              break;
            }
          }
        }
      }
    }
  }
}

/**
 * Adds property and field order by directions to an index EntityFieldQuery.
 *
 * @param $query
 *   The EntityFieldQuery object being built for the index query.
 * @param $entity_type
 *   Machine-name of the entity type of the index query.
 * @param $sort_by
 *   An array of database fields to sort the query by, with sort fields being
 *   valid properties, single column field names, or multi-column field column
 *   names for the matching entity type.
 * @param $sort_order
 *   The corresponding sort orders for the fields specified in the $sort_by
 *   array; one of either 'DESC' or 'ASC'.
 */
function commerce_services_index_query_sort($query, $entity_type, $sort_by, $sort_order) {
  // Loop over each sort field to add them as property or field order by
  // directions on the query object. This function assumes the $sort_by and
  // $sort_order arrays contain an equal number of elements with keys matching
  // the sort field to the appropriate sort order.
  foreach ($sort_by as $sort_key => $sort_field) {
    // Determine the corresponding sort direction for this sort field,
    // defaulting to DESC in case of an erroneous request.
    $direction = 'DESC';

    if (!empty($sort_order[$sort_key])) {
      $direction = strtoupper($sort_order[$sort_key]);
    }

    // If the current sort field is a property, use a property condition.
    $properties = commerce_services_entity_type_properties($entity_type);

    if (in_array($sort_field, array_keys($properties))) {
      $query->propertyOrderBy($properties[$sort_field], $direction);
    }
    else {
      // Look for the field name among the entity type's field list.
      foreach (commerce_services_entity_type_fields($entity_type) as $field_name => $field_type) {
        // If the sort field begins with a field name, then either the sort
        // field is the field name or is a column of the field.
        if (strpos($sort_field, $field_name) === 0) {
          $field_info = field_info_field($field_name);

          // If it is the field name and the field type has a single column
          // schema, add the field condition to the index query.
          if ($field_name == $sort_field && count($field_info['columns']) == 1) {
            $column = key($field_info['columns']);
            $query->fieldOrderBy($field_name, $column, $direction);
            break;
          }
          else {
            // Otherwise if the sort field contains a valid column specification
            // for the field type, add the field condition to the index query.
            $column = substr($sort_field, strlen($field_name) + 1);

            if (in_array($column, array_keys($field_info['columns']))) {
              $query->fieldOrderBy($field_name, $column, $direction);
              break;
            }
          }
        }
      }
    }
  }
}

/**
 * Expands entity reference field values into full entities in a corresponding
 * property on the given entity to a specified depth of child entities.
 *
 * @param $entity_type
 *   The machine-name entity type of the given entity.
 * @param $entity
 *   The entity whose reference field values should be expanded.
 * @param $depth
 *   The depth to which referenced entities should be expanded; a depth of 1
 *   means only the reference field values on the entity passed to the function
 *   should be expanded, 2 means those and the entities they reference, etc.
 * @param $flatten_fields
 *   Boolean indicating whether or not field value arrays should be flattened.
 */
function commerce_services_expand_entities($entity_type, $entity, $depth, $flatten_fields) {
  // Extract the bundle name.
  $bundle = field_extract_bundle($entity_type, $entity);

  // Look for each type of Commerce reference field on the given entity.
  foreach (array('commerce_product_reference', 'commerce_line_item_reference', 'commerce_customer_profile_reference') as $field_type) {
    // Look for reference field instances of each type on the entity.
    foreach (field_info_instances($entity_type, $bundle) as $field_name => $instance) {
      $entities_field_name = $field_name . '_entities';
      $field_info = field_info_field($field_name);

      if ($field_info['type'] == $field_type) {
        // Extract the type of referenced entity from the property info.
        $property_info = entity_get_property_info($entity_type);

        if (!empty($property_info['bundles'][$bundle]['properties'][$field_name]['type'])) {
          $referenced_entity_type = $property_info['bundles'][$bundle]['properties'][$field_name]['type'];
          $entity_wrapper = entity_metadata_wrapper($entity_type, $entity);

          // If the field is multi-value, extract the entity type from within
          // the list markup and expand the whole list.
          if (substr($referenced_entity_type, 0, 5) == 'list<') {
            $referenced_entity_type = substr($referenced_entity_type, 5, strlen($referenced_entity_type) - 6);

            foreach ($entity_wrapper->{$field_name} as $delta => $referenced_entity_wrapper) {
              // Extract the entity from the wrapper.
              $referenced_entity_id = $referenced_entity_wrapper->raw();

              if (!empty($referenced_entity_id)) {
                $referenced_entity = clone($referenced_entity_wrapper->value());

                // Decorate the entity.
                commerce_services_decorate_entity($referenced_entity_type, $referenced_entity);

                // If our entity traversal depth has not reduced to 1, then we
                // need to recurse to expand any entity reference fields present
                // on the referenced entity.
                if ($depth > 1) {
                  commerce_services_expand_entities($referenced_entity_type, $referenced_entity, $depth - 1, $flatten_fields);
                }

                // Flatten field value arrays on the referenced entity if directed.
                if ($flatten_fields) {
                  commerce_services_flatten_fields($referenced_entity_type, $referenced_entity);
                }

                // And finally set the referenced entity to be the new value at
                // the current delta in the reference field value array.
                $entity->{$entities_field_name}[$referenced_entity_id] = $referenced_entity;
              }
            }
          }
          else {
            // Extract the entity and its ID from the wrapper.
            $referenced_entity_id = $entity_wrapper->{$field_name}->raw();

            if (!empty($referenced_entity_id)) {
              $referenced_entity = clone($entity_wrapper->{$field_name}->value());

              // Decorate the entity.
              commerce_services_decorate_entity($referenced_entity_type, $referenced_entity);

              // If our entity traversal depth has not reduced to 1, then we
              // need to recurse to expand any entity reference fields present
              // on the referenced entity.
              if ($depth > 1) {
                commerce_services_expand_entities($referenced_entity_type, $referenced_entity, $depth - 1, $flatten_fields);
              }

              // Flatten field value arrays on the referenced entity if directed.
              if ($flatten_fields) {
                commerce_services_flatten_fields($referenced_entity_type, $referenced_entity);
              }

              // And finally set the referenced entity to be the new value at the
              // current delta in the reference field value array.
              $entity->{$entities_field_name}[$referenced_entity_id] = $referenced_entity;
            }
          }
        }
      }
    }
  }
}

/**
 * Flattens field value arrays on the given entity.
 *
 * Field flattening in Commerce Services involves reducing their value arrays to
 * just the current language of the entity and reducing fields with single
 * column schemas to simple scalar values or arrays of scalar values.
 *
 * Note that because this function irreparably alters an entity's structure, it
 * should only be called using a clone of the entity whose field value arrays
 * should be flattened. Otherwise the flattening will affect the entity as
 * stored in the entity cache, causing potential errors should that entity be
 * loaded and manipulated later in the same request.
 *
 * @param $entity_type
 *   The machine-name entity type of the given entity.
 * @param $cloned_entity
 *   A clone of the entity whose field value arrays should be flattened.
 */
function commerce_services_flatten_fields($entity_type, $cloned_entity) {
  $bundle = field_extract_bundle($entity_type, $cloned_entity);
  $clone_wrapper = entity_metadata_wrapper($entity_type, $cloned_entity);

  // Loop over every field instance on the given entity.
  foreach (field_info_instances($entity_type, $bundle) as $field_name => $instance) {
    // Set the field property to the raw wrapper value, which applies the
    // desired flattening of the value array.
    $cloned_entity->{$field_name} = $clone_wrapper->{$field_name}->raw();
  }
}

/**
 * Decorate the given entity with additional helper properties based on its type.
 *
 * Product entities will be given an attribute_fields property whose value is an
 * array of product attribute fields on the product.
 *
 * Any instance of a price field will be given a corresponding property named
 * [field_name]_formatted whose value is the currency formatted price.
 *
 * Any instance of a file or image field will be given a corresponding property
 * named [field_name]_url whose value is the URL to the file or image.
 *
 * @param $entity_type
 *   The machine-name entity type of the given entity.
 * @param $entity
 *   The entity whose field value arrays should be flattened.
 */
function commerce_services_decorate_entity($entity_type, $entity) {
  $bundle = field_extract_bundle($entity_type, $entity);

  // If the entity is a product, add a list of its attribute fields to it.
  if ($entity_type == 'commerce_product') {
    $entity->attribute_fields = array();
  }

  // Loop over every field instance on the given entity.
  foreach (field_info_instances($entity_type, $bundle) as $field_name => $instance) {
    $field_info = field_info_field($field_name);

    // If the current field instance functions as a product attribute field, add
    // it to the array.
    if (module_exists('commerce_cart')) {
      $commerce_cart_settings = commerce_cart_field_instance_attribute_settings($instance);

      if (!empty($commerce_cart_settings['attribute_field'])) {
        $entity->attribute_fields[] = $field_name;
      }
    }

    // Add formatted price fields to correspond with every price field instance.
    if ($field_info['type'] == 'commerce_price') {
      $entity_wrapper = entity_metadata_wrapper($entity_type, $entity);
      $formatted_field_name = $field_name . '_formatted';

      // Set the formatted price for a single value field.
      if ($field_info['cardinality'] == 1) {
        $entity->{$formatted_field_name} = commerce_currency_format($entity_wrapper->{$field_name}->amount->value(), $entity_wrapper->{$field_name}->currency_code->value(), $entity);
      }
      else {
        // Otherwise loop over the field and format each value.
        foreach ($entity_wrapper->{$field_name} as $delta => $price_wrapper) {
          $entity->{$formatted_field_name}[$delta] = commerce_currency_format($price_wrapper->amount->value(), $price_wrapper->currency_code->value(), $entity);
        }
      }
    }

    // Add a direct URL to correspond with every file field instance.
    if (in_array($field_info['type'], array('file', 'image'))) {
      $entity_wrapper =  entity_metadata_wrapper($entity_type, $entity);
      $url_field_name = $field_name . '_url';

      // Set the formatted price for a single value field.
      if ($field_info['cardinality'] == 1) {
        $field_value = $entity_wrapper->{$field_name}->raw();
        $entity->{$url_field_name} = '';
        $url = NULL;

        // If the field value contains a URI...
        if (!empty($field_value['uri'])) {
          // And we can generate a URL to the file at that URI...
          $url = file_create_url($field_value['uri']);

          if (!empty($url)) {
            // Add it to the entity using the URL field name.
            $entity->{$url_field_name} = $url;
          }
        }
      }
      else {
        // Otherwise loop over the field and generate each URL.
        $entity->{$url_field_name} = array();

        foreach ($entity_wrapper->{$field_name} as $delta => $field_wrapper) {
          $field_value = $field_wrapper->raw();
          $url = NULL;

          // If the field value contains a URI...
          if (!empty($field_value['uri'])) {
            // And we can generate a URL to the file at that URI...
            $url = file_create_url($field_value['uri']);

            if (!empty($url)) {
              // Add it to the entity using the URL field name.
              $entity->{$url_field_name}[$delta] = $url;
            }
          }

          // If the field value did not have a URI or the URL to the file could not
          // be determined, add an empty URL string to the entity.
          if (empty($url)) {
            $entity->{$url_field_name}[$delta] = '';
          }
        }
      }
    }
  }
}
